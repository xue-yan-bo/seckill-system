# 电商秒杀系统 - 面试准备手册

## 📚 目录

1. [项目介绍话术](#1-项目介绍话术)
2. [高频技术问题](#2-高频技术问题)
3. [系统架构问题](#3-系统架构问题)
4. [性能优化问题](#4-性能优化问题)
5. [分布式问题](#5-分布式问题)
6. [数据库问题](#6-数据库问题)
7. [场景设计题](#7-场景设计题)
8. [项目难点与亮点](#8-项目难点与亮点)

---

## 1. 项目介绍话术

### 📌 标准版本（1-2分钟）

"各位面试官好，我介绍一下这个电商秒杀系统项目。

**项目背景**：这是一个模拟真实电商大促场景的秒杀系统，主要解决高并发场景下的库存管理和性能优化问题。

**技术架构**：系统采用Spring Boot微服务架构，前后端分离。后端分为4个核心服务：用户服务、商品服务、秒杀服务、订单服务。前端使用Vue 3开发。

**核心挑战**：主要解决了三个问题：
1. **库存超卖**：通过Redisson分布式锁+MyBatis Plus乐观锁双重保障
2. **性能瓶颈**：Redis缓存预热+RabbitMQ异步处理，响应时间从800ms降到200ms
3. **系统安全**：JWT认证+AOP限流+全局异常处理

**技术亮点**：
- 分布式锁保证集群环境下的数据一致性
- 消息队列实现削峰填谷
- 多级缓存提升查询性能
- 完整的监控和日志体系

系统最终支持1000+并发用户，TPS达到500+，零库存超卖。"

### 📌 精简版本（30秒）

"这是一个高并发电商秒杀系统，采用Spring Boot微服务架构。主要技术亮点是用分布式锁解决超卖问题，用Redis缓存和RabbitMQ异步处理提升性能。系统支持1000+并发，响应时间在200ms以内。"

---

## 2. 高频技术问题

### Q1: 如何防止库存超卖？

**回答要点**：

我采用了**三层防护机制**：

**第一层：分布式锁（Redisson）**
```java
// 伪代码
RLock lock = redissonClient.getLock("seckill:lock:" + activityId);
try {
    boolean isLocked = lock.tryLock(5, 10, TimeUnit.SECONDS);
    if (isLocked) {
        // 扣减库存
    }
} finally {
    lock.unlock();
}
```
- 保证同一时刻只有一个请求能扣减库存
- 设置锁超时时间防止死锁
- Redisson自动续期机制（看门狗）

**第二层：乐观锁（数据库）**
```sql
UPDATE tb_seckill_activity 
SET stock = stock - 1, version = version + 1 
WHERE id = ? AND stock >= 1 AND version = ?
```
- 使用版本号机制
- CAS操作保证原子性
- 更新失败直接返回

**第三层：Redis库存预检**
- 在Redis中维护库存副本
- 请求先检查Redis，库存不足直接返回
- 减少数据库压力

**为什么这样设计**：
- 分布式锁解决集群环境的并发问题
- 乐观锁作为最后防线，避免数据库层面超卖
- Redis预检快速失败，提高响应速度

---

### Q2: 为什么选择Redisson而不是Redis原生命令？

**回答要点**：

**Redisson的优势**：

1. **自动续期（看门狗机制）**
   - 避免业务执行时间超过锁过期时间
   - 默认每10秒续期一次
   - 原生Redis需要手动实现

2. **可重入锁**
   - 同一线程可以多次获取锁
   - 避免死锁问题

3. **公平锁支持**
   - 按照请求顺序获取锁
   - 防止某些请求长时间得不到锁

4. **封装完善**
   - 自动处理加锁、解锁、异常
   - 代码更简洁可靠

**对比示例**：
```java
// Redisson：简单可靠
RLock lock = redissonClient.getLock(key);
lock.lock();
try {
    // 业务逻辑
} finally {
    lock.unlock();
}

// Redis原生：需要考虑很多问题
String lockValue = UUID.randomUUID().toString();
Boolean success = redisTemplate.opsForValue()
    .setIfAbsent(key, lockValue, 30, TimeUnit.SECONDS);
try {
    // 业务逻辑
    // 需要手动续期
    // 需要防止误删别人的锁
} finally {
    // Lua脚本删除锁
}
```

---

### Q3: Redis缓存和数据库数据不一致怎么办？

**回答要点**：

**我采用的策略是 Cache-Aside（旁路缓存）模式**：

**读操作**：
1. 先查询缓存
2. 缓存命中直接返回
3. 缓存未命中，查询数据库
4. 将数据写入缓存

**写操作**：
1. 先更新数据库
2. 删除缓存（而不是更新缓存）

**为什么删除而不是更新**：
- 写多读少场景，更新缓存浪费性能
- 避免并发更新缓存时的数据不一致
- 让下次读取时重新加载最新数据

**如何保证最终一致性**：

1. **设置过期时间**
   ```java
   redisUtil.set(key, value, 30, TimeUnit.MINUTES);
   ```
   - 即使删除失败，缓存也会过期
   - 权衡实时性和性能

2. **延迟双删**
   ```java
   // 更新数据库
   updateDatabase();
   // 删除缓存
   deleteCache();
   // 延迟后再删除一次
   Thread.sleep(500);
   deleteCache();
   ```
   - 处理并发读写导致的脏数据

3. **订阅Binlog**（生产环境推荐）
   - 使用Canal监听MySQL binlog
   - 数据变更时自动删除缓存
   - 彻底解决不一致问题

**实际使用的场景**：
- 商品信息：允许短暂不一致，使用过期时间
- 库存数据：实时性要求高，先扣库存再删缓存
- 秒杀活动：预加载到Redis，很少变更

---

### Q4: RabbitMQ消息丢失怎么处理？

**回答要点**：

**三个环节都要保证**：

**1. 生产者确认（Publisher Confirms）**
```java
rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -> {
    if (ack) {
        log.info("消息发送成功");
    } else {
        log.error("消息发送失败: {}", cause);
        // 重试或记录
    }
});
```

**2. 消息持久化**
```java
// 队列持久化
@Bean
public Queue orderQueue() {
    return QueueBuilder.durable("seckill.order.queue").build();
}

// 消息持久化
rabbitTemplate.convertAndSend(exchange, routingKey, message, 
    msg -> {
        msg.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);
        return msg;
    });
```

**3. 消费者手动确认（Manual ACK）**
```java
@RabbitListener(queues = "seckill.order.queue")
public void handleMessage(String message, Channel channel, Message msg) {
    try {
        // 处理消息
        processOrder(message);
        // 手动确认
        channel.basicAck(msg.getMessageProperties().getDeliveryTag(), false);
    } catch (Exception e) {
        // 拒绝并重新入队
        channel.basicNack(msg.getMessageProperties().getDeliveryTag(), false, true);
    }
}
```

**完整保障流程**：
1. 生产者发送消息等待确认
2. RabbitMQ持久化到磁盘
3. 消费者处理成功后手动ACK
4. 如果消费失败，重新入队或进入死信队列

**我的项目实现**：
- 使用手动ACK确保消息被正确处理
- 消息持久化防止RabbitMQ崩溃丢失
- 设置重试机制，失败3次后进入死信队列人工处理

---

### Q5: 如何实现接口限流？

**回答要点**：

**我使用自定义注解+AOP+Redis实现**：

**1. 定义限流注解**
```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RateLimit {
    String key() default "rate_limit:";
    int time() default 60;  // 时间窗口（秒）
    int count() default 100; // 限制次数
}
```

**2. AOP切面实现**
```java
@Around("@annotation(rateLimit)")
public Object around(ProceedingJoinPoint pjp, RateLimit rateLimit) {
    String key = rateLimit.key() + getIp() + ":" + methodName;
    Long count = redisTemplate.opsForValue().increment(key);
    
    if (count == 1) {
        redisTemplate.expire(key, rateLimit.time(), TimeUnit.SECONDS);
    }
    
    if (count > rateLimit.count()) {
        throw new BusinessException("访问过于频繁");
    }
    
    return pjp.proceed();
}
```

**3. 使用示例**
```java
@PostMapping("/{activityId}")
@RateLimit(time = 1, count = 1) // 每秒最多1次
public Result doSeckill(@PathVariable Long activityId) {
    // 秒杀逻辑
}
```

**限流算法选择**：
- **固定窗口**：实现简单，但有临界问题
- **滑动窗口**：更精确，Redis Sorted Set实现
- **令牌桶**：支持突发流量，Guava RateLimiter
- **漏桶**：流量整形，平滑限流

**我的选择**：固定窗口+Redis，因为：
- 实现简单，性能好
- 满足秒杀场景需求
- 支持分布式部署

---

## 3. 系统架构问题

### Q6: 介绍一下系统的整体架构？

**回答要点**：

**分层架构**：
```
┌─────────────────────────────────────┐
│          前端层（Vue 3）              │
│     - 用户界面                        │
│     - 路由管理                        │
│     - 状态管理                        │
└─────────────────────────────────────┘
                 ↓ HTTP/REST
┌─────────────────────────────────────┐
│          网关层（可选）               │
│     - 路由转发                        │
│     - 负载均衡                        │
│     - 统一鉴权                        │
└─────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────┐
│          服务层（Spring Boot）        │
│  ┌──────────┬──────────┬──────────┐ │
│  │用户服务  │商品服务  │秒杀服务  │ │
│  │:8081     │:8082     │:8083     │ │
│  └──────────┴──────────┴──────────┘ │
│  ┌──────────┬──────────┬──────────┐ │
│  │订单服务  │公共模块  │实体模块  │ │
│  │:8084     │          │          │ │
│  └──────────┴──────────┴──────────┘ │
└─────────────────────────────────────┘
          ↓                 ↓
┌─────────────────┐  ┌─────────────────┐
│   缓存层        │  │   消息队列      │
│   Redis         │  │   RabbitMQ      │
│   - 缓存        │  │   - 异步处理    │
│   - 分布式锁    │  │   - 削峰填谷    │
└─────────────────┘  └─────────────────┘
          ↓
┌─────────────────────────────────────┐
│          数据层（MySQL）              │
│     - 用户表                          │
│     - 商品表                          │
│     - 秒杀活动表                      │
│     - 订单表                          │
└─────────────────────────────────────┘
```

**核心模块说明**：

1. **seckill-common**：公共工具模块
   - JWT工具、MD5工具、Redis工具
   - AOP切面（日志、限流）
   - 全局异常处理

2. **seckill-user**：用户服务（8081）
   - 用户注册、登录
   - JWT Token生成和验证
   - 用户信息管理

3. **seckill-product**：商品服务（8082）
   - 商品CRUD
   - 库存管理（乐观锁）
   - Redis缓存

4. **seckill-seckill**：秒杀服务（8083）
   - 秒杀活动管理
   - 分布式锁控制并发
   - 发送MQ消息

5. **seckill-order**：订单服务（8084）
   - 监听MQ消息
   - 异步创建订单
   - 订单管理

**技术选型理由**：
- **微服务**：业务隔离，独立部署
- **Redis**：高性能缓存，分布式锁
- **RabbitMQ**：异步解耦，削峰填谷
- **MyBatis Plus**：简化CRUD，乐观锁支持

---

### Q7: 为什么要拆分成多个服务？

**回答要点**：

**拆分原因**：

1. **业务隔离**
   - 各服务专注自己的业务
   - 降低代码耦合度
   - 便于团队协作开发

2. **独立部署**
   - 某个服务升级不影响其他服务
   - 可以单独扩容高负载服务
   - 降低部署风险

3. **技术栈灵活**
   - 不同服务可以选择不同技术
   - 便于技术升级和优化

4. **故障隔离**
   - 某个服务故障不会导致整个系统崩溃
   - 提高系统可用性

**拆分原则**：
- 按业务领域拆分（DDD思想）
- 单一职责原则
- 高内聚低耦合

**实际效果**：
- 秒杀服务压力大时，可以单独扩容
- 订单服务异步处理，不影响秒杀响应
- 代码结构清晰，维护方便

---

## 4. 性能优化问题

### Q8: 如何做性能优化的？具体效果如何？

**回答要点**：

**优化措施**：

**1. 缓存优化**
- **问题**：商品查询频繁，数据库压力大
- **方案**：Redis缓存热点商品数据
- **效果**：查询响应从150ms降至20ms，缓存命中率95%+

**2. 异步处理**
- **问题**：秒杀后同步创建订单，响应慢
- **方案**：RabbitMQ异步创建订单
- **效果**：响应时间从800ms降至200ms，提升75%

**3. 数据库优化**
- **索引优化**：在查询条件字段上建立索引
- **连接池**：Druid连接池，最大20个连接
- **批量操作**：MyBatis Plus批量插入

**4. 前端优化**
- **按需加载**：Vue Router懒加载
- **CDN**：静态资源CDN加速
- **Gzip压缩**：减小传输体积

**5. Redis优化**
- **数据预热**：启动时加载秒杀活动到Redis
- **合理过期**：设置30分钟过期时间
- **序列化优化**：使用JSON序列化

**性能数据对比**：

| 指标 | 优化前 | 优化后 | 提升 |
|------|--------|--------|------|
| 商品查询响应 | 150ms | 20ms | 86% |
| 秒杀响应时间 | 800ms | 200ms | 75% |
| 并发支持 | 200 | 1000+ | 400% |
| 数据库QPS | 500 | 200 | 减少60% |
| 缓存命中率 | 0% | 95%+ | - |

---

### Q9: 如何进行压力测试的？

**回答要点**：

**测试工具**：JMeter / Apache Bench

**测试场景**：

**1. 商品列表查询**
```
- 并发用户：1000
- 持续时间：60秒
- 预期TPS：500+
- 预期响应时间：<100ms
```

**2. 秒杀接口**
```
- 并发用户：1000
- 库存：100
- 预期：100个成功，900个失败
- 响应时间：<300ms
```

**测试步骤**：
1. 准备测试数据（用户、商品、活动）
2. 配置JMeter线程组和HTTP请求
3. 设置断言（响应码、响应内容）
4. 运行测试并收集结果
5. 分析瓶颈，针对性优化

**关键指标**：
- **TPS**：每秒事务数
- **响应时间**：P50/P95/P99
- **错误率**：<1%
- **CPU/内存**：<80%

**问题排查**：
- JVM监控（jvisualvm）
- SQL慢查询日志
- Redis监控
- 线程dump分析

---

## 5. 分布式问题

### Q10: 分布式锁的实现原理？可能出现的问题？

**回答要点**：

**Redisson分布式锁原理**：

**1. 加锁（Lua脚本保证原子性）**
```lua
if (redis.call('exists', KEYS[1]) == 0) then
    redis.call('hset', KEYS[1], ARGV[2], 1);
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return nil;
end;
```

**2. 看门狗续期**
- 默认30秒过期
- 每10秒检查一次
- 如果业务未完成，自动续期30秒

**3. 解锁**
```lua
if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then
    return nil;
end;
redis.call('del', KEYS[1]);
```

**可能的问题**：

**1. 死锁问题**
- **原因**：获取锁后，服务宕机未释放
- **解决**：设置锁过期时间

**2. 误删锁问题**
- **原因**：A的锁过期，B获取锁，A删除了B的锁
- **解决**：锁值使用UUID，删除时校验

**3. 锁续期问题**
- **原因**：业务执行时间超过锁过期时间
- **解决**：Redisson看门狗机制自动续期

**4. Redis主从切换问题**
- **原因**：主节点宕机，锁数据未同步到从节点
- **解决**：使用RedLock算法（多个独立Redis实例）

**我的项目使用**：
```java
RLock lock = redissonClient.getLock("seckill:lock:" + activityId);
try {
    boolean isLocked = lock.tryLock(5, 10, TimeUnit.SECONDS);
    // 5秒等待时间，10秒锁自动释放时间
    if (isLocked) {
        // 业务逻辑
    }
} finally {
    if (lock.isHeldByCurrentThread()) {
        lock.unlock();
    }
}
```

---

### Q11: 如果Redis宕机了怎么办？

**回答要点**：

**多层防护**：

**1. Redis高可用**
- **主从复制**：一主二从，读写分离
- **哨兵模式**：自动故障转移
- **集群模式**：数据分片，高可用

**2. 降级方案**
```java
try {
    // 尝试使用Redis
    return redisTemplate.opsForValue().get(key);
} catch (Exception e) {
    log.error("Redis异常，降级查询数据库", e);
    // 降级到数据库
    return database.query(key);
}
```

**3. 熔断保护**
- 使用Sentinel/Hystrix
- Redis连续失败N次后熔断
- 直接返回默认值或查询数据库

**4. 本地缓存**
- 使用Caffeine/Guava Cache
- 作为L1缓存，Redis作为L2缓存
- Redis故障时使用本地缓存

**5. 限流保护**
- Redis故障时，限制请求量
- 防止数据库被打垮

**我的项目实现**：
- 设置Redis连接超时时间
- 异常时降级到数据库查询
- 关键业务（秒杀）要求Redis必须可用

---

## 6. 数据库问题

### Q12: 数据库表结构设计？为什么这样设计？

**回答要点**：

**核心表结构**：

**1. 用户表（tb_user）**
```sql
CREATE TABLE tb_user (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,
    password VARCHAR(100) NOT NULL,
    nickname VARCHAR(50),
    phone VARCHAR(20),
    email VARCHAR(50),
    status TINYINT DEFAULT 0,  -- 0正常 1禁用
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    update_time DATETIME ON UPDATE CURRENT_TIMESTAMP,
    deleted TINYINT DEFAULT 0,  -- 逻辑删除
    INDEX idx_phone(phone),
    INDEX idx_email(email)
);
```

**2. 商品表（tb_product）**
```sql
CREATE TABLE tb_product (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    stock INT NOT NULL DEFAULT 0,
    version INT NOT NULL DEFAULT 0,  -- 乐观锁版本号
    sales INT DEFAULT 0,
    status TINYINT DEFAULT 1,
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    deleted TINYINT DEFAULT 0,
    INDEX idx_name(name),
    INDEX idx_status(status)
);
```

**3. 秒杀活动表（tb_seckill_activity）**
```sql
CREATE TABLE tb_seckill_activity (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    product_id BIGINT NOT NULL,
    seckill_price DECIMAL(10,2) NOT NULL,
    seckill_stock INT NOT NULL,
    version INT NOT NULL DEFAULT 0,  -- 乐观锁
    start_time DATETIME NOT NULL,
    end_time DATETIME NOT NULL,
    status TINYINT DEFAULT 0,  -- 0未开始 1进行中 2已结束
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_product_id(product_id),
    INDEX idx_start_time(start_time),
    INDEX idx_end_time(end_time)
);
```

**4. 订单表（tb_order）**
```sql
CREATE TABLE tb_order (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_no VARCHAR(50) UNIQUE NOT NULL,
    user_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    activity_id BIGINT,
    quantity INT NOT NULL DEFAULT 1,
    total_amount DECIMAL(10,2) NOT NULL,
    status TINYINT DEFAULT 0,  -- 0待支付 1已支付 2已取消
    pay_time DATETIME,
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_user_id(user_id),
    INDEX idx_order_no(order_no),
    INDEX idx_create_time(create_time)
);
```

**设计要点**：

1. **版本号字段（version）**
   - 实现乐观锁
   - 防止并发更新冲突

2. **索引设计**
   - 唯一索引：username, order_no
   - 普通索引：查询条件字段
   - 复合索引：多字段查询

3. **时间字段**
   - create_time：创建时间
   - update_time：自动更新
   - 便于数据追溯

4. **逻辑删除**
   - deleted字段
   - 不物理删除数据
   - 便于数据恢复

5. **状态字段**
   - 使用TINYINT存储状态
   - 节省空间，查询快

---

### Q13: 如何处理慢SQL？

**回答要点**：

**排查方法**：

**1. 开启慢查询日志**
```sql
-- 查看慢查询配置
SHOW VARIABLES LIKE 'slow_query%';
-- 设置慢查询阈值（秒）
SET GLOBAL slow_query_log = ON;
SET GLOBAL long_query_time = 2;
```

**2. 使用EXPLAIN分析**
```sql
EXPLAIN SELECT * FROM tb_order WHERE user_id = 1;
```
关注：
- type：连接类型（ALL最差，ref较好）
- rows：扫描行数
- Extra：额外信息

**3. 查看执行计划**
```sql
EXPLAIN ANALYZE SELECT ...;
```

**优化方案**：

**1. 添加索引**
```sql
-- 针对查询条件添加索引
CREATE INDEX idx_user_id ON tb_order(user_id);
-- 复合索引
CREATE INDEX idx_user_status ON tb_order(user_id, status);
```

**2. 避免全表扫描**
- WHERE条件使用索引字段
- 避免在索引字段上使用函数
- 避免隐式类型转换

**3. 优化查询语句**
```sql
-- 不好：SELECT *
SELECT id, name, price FROM tb_product;

-- 不好：子查询
SELECT * FROM tb_order WHERE user_id IN (SELECT id FROM tb_user);

-- 好：JOIN
SELECT o.* FROM tb_order o JOIN tb_user u ON o.user_id = u.id;
```

**4. 分页优化**
```sql
-- 不好：LIMIT深分页
SELECT * FROM tb_order LIMIT 100000, 20;

-- 好：使用id范围
SELECT * FROM tb_order WHERE id > 100000 LIMIT 20;
```

**5. 读写分离**
- 主库写，从库读
- 降低主库压力

**我的项目实践**：
- 所有查询字段都添加了索引
- 使用MyBatis Plus分页插件
- 定期分析慢查询日志
- 避免SELECT *，只查询需要的字段

---

## 7. 场景设计题

### Q14: 如果让你设计一个秒杀系统，你会怎么设计？

**回答要点**：

**整体思路：削峰 + 限流 + 异步 + 缓存**

**1. 前端层面**
- 按钮防重复点击
- 倒计时未到禁止点击
- 本地验证（客户端限流）

**2. 网关层面**
- Nginx限流（limit_req_zone）
- IP黑名单
- 防刷策略

**3. 应用层面**
- 接口限流（1秒1次）
- Token令牌桶
- 人机验证（验证码）

**4. 服务层面**
- Redis库存预减
- 分布式锁
- 消息队列异步处理

**5. 数据层面**
- 乐观锁防超卖
- 读写分离
- 分库分表

**流程设计**：
```
用户点击秒杀
    ↓
前端防重复 → 失败：禁止点击
    ↓ 成功
网关限流 → 失败：返回"人太多了"
    ↓ 成功
接口限流 → 失败：返回"操作频繁"
    ↓ 成功
Redis检查库存 → 失败：返回"已售罄"
    ↓ 成功
获取分布式锁 → 失败：返回"请重试"
    ↓ 成功
扣减Redis库存
    ↓
发送MQ消息
    ↓
立即返回"秒杀成功"
    ↓
异步创建订单（扣减数据库库存）
```

**关键点**：
1. **多级限流**：前端+网关+应用
2. **快速失败**：Redis预检，库存不足立即返回
3. **异步处理**：秒杀成功立即返回，订单异步创建
4. **防超卖**：分布式锁+乐观锁双保险

---

### Q15: 如果秒杀商品有100件，10000人抢，如何保证公平性？

**回答要点**：

**公平性保障方案**：

**1. 先到先得模式（我的实现）**
- 按请求到达时间处理
- 分布式锁串行化处理
- 谁先拿到锁谁先处理

**2. 队列模式**
```java
// 所有请求进入队列
redisTemplate.opsForList().rightPush("seckill:queue:" + activityId, userId);
// 单线程按顺序处理
while (stock > 0) {
    String userId = redisTemplate.opsForList().leftPop("seckill:queue:" + activityId);
    processSeckill(userId);
}
```

**3. 令牌桶模式**
```java
// 生成100个令牌
for (int i = 0; i < 100; i++) {
    String token = UUID.randomUUID().toString();
    redisTemplate.opsForSet().add("seckill:tokens:" + activityId, token);
}
// 用户获取令牌
String token = redisTemplate.opsForSet().pop("seckill:tokens:" + activityId);
if (token != null) {
    // 秒杀成功
}
```

**4. 分时段放量**
```java
// 每秒放10件
@Scheduled(fixedRate = 1000)
public void releaseStock() {
    redisTemplate.opsForValue().set("seckill:available", 10);
}
```

**防止黄牛**：
1. 限制每个用户只能抢购一次
2. 实名认证
3. 手机号验证
4. 人机验证（滑块、验证码）
5. 风控规则（IP、设备指纹）

**我的实现**：
- 用户维度限制：每个活动每个用户只能参与一次
- IP限流：同一IP 1秒内最多1次请求
- 分布式锁保证串行处理
- Redis记录用户参与记录，防止重复

---

## 8. 项目难点与亮点

### Q16: 项目中遇到的最大难点是什么？如何解决的？

**回答要点**：

**难点：高并发场景下的库存一致性问题**

**问题描述**：
在并发场景下，多个请求同时扣减库存，容易出现：
1. 库存超卖（卖出100件，实际库存只有80件）
2. 库存扣减失败（有库存但扣减失败）
3. 性能瓶颈（数据库锁表导致性能下降）

**解决过程**：

**第一版：数据库悲观锁（FOR UPDATE）**
```sql
SELECT * FROM tb_product WHERE id = ? FOR UPDATE;
UPDATE tb_product SET stock = stock - 1 WHERE id = ?;
```
- 问题：性能太差，并发100就支持不了
- 原因：所有请求都阻塞在数据库锁上

**第二版：乐观锁（版本号）**
```sql
UPDATE tb_product 
SET stock = stock - 1, version = version + 1 
WHERE id = ? AND version = ? AND stock > 0;
```
- 改进：性能提升，支持500并发
- 问题：并发高时失败率很高（90%以上）
- 原因：版本号冲突导致大量重试

**第三版：Redis + 乐观锁**
```java
// 1. Redis预减库存（快速失败）
Long stock = redisTemplate.opsForValue().decrement("stock:" + productId);
if (stock < 0) {
    return "库存不足";
}

// 2. 数据库乐观锁扣减
int rows = mapper.deductStock(productId, version);
if (rows == 0) {
    // 回滚Redis
    redisTemplate.opsForValue().increment("stock:" + productId);
    return "扣减失败";
}
```
- 改进：性能大幅提升，支持1000+并发
- 问题：Redis和数据库可能不一致

**最终版：分布式锁 + Redis + 乐观锁**
```java
RLock lock = redissonClient.getLock("seckill:" + activityId);
try {
    lock.lock(5, TimeUnit.SECONDS);
    
    // 1. Redis检查库存
    if (getRedisStock() <= 0) {
        return "库存不足";
    }
    
    // 2. 数据库乐观锁扣减
    int rows = deductStock(activityId, version);
    if (rows == 0) {
        return "扣减失败，请重试";
    }
    
    // 3. Redis扣减库存
    redisTemplate.opsForValue().decrement("stock:" + activityId);
    
    // 4. 发送MQ异步创建订单
    sendMQ(userId, activityId);
    
    return "秒杀成功";
} finally {
    lock.unlock();
}
```

**最终效果**：
- 支持1000+并发
- 零库存超卖
- 响应时间200ms以内
- TPS达到500+

**关键点**：
1. 分布式锁保证串行化
2. Redis快速失败
3. 乐观锁最后防线
4. 消息队列异步处理

---

### Q17: 这个项目的技术亮点是什么？

**回答要点**：

**亮点一：完整的高并发解决方案**
- 不是简单的CRUD，而是真正考虑了高并发场景
- 分布式锁、乐观锁、限流、缓存、异步等技术综合运用
- 有完整的性能数据支撑

**亮点二：微服务架构实践**
- 不是单体应用，采用多模块微服务设计
- 业务拆分合理，职责清晰
- 模块间通过消息队列解耦

**亮点三：工程化实践**
- 统一返回结果格式
- 全局异常处理
- AOP日志监控
- 代码规范，注释完整

**亮点四：性能优化思路清晰**
- 有明确的优化前后对比数据
- 多级缓存、异步处理、连接池等多种优化手段
- 能说清楚为什么要这样做

**亮点五：生产级别的代码质量**
- 考虑了异常处理（消息丢失、缓存失效）
- 考虑了安全性（JWT、限流、权限）
- 考虑了可维护性（日志、监控）

**亮点六：前后端全栈**
- 不只是后端，还有完整的前端项目
- Vue 3 + Element Plus，现代化技术栈
- 前后端联调，完整的系统

**总结**：
这不是一个简单的Demo项目，而是一个考虑了高并发、分布式、性能优化、工程化的生产级系统。虽然是个人项目，但技术选型、架构设计、代码质量都接近真实商业项目水平。

---

## 💡 面试技巧

### 1. 回答结构
- **总**：先简要回答问题
- **分**：分点详细说明
- **总**：总结效果或思考

### 2. 数据支撑
- 多用具体数字（TPS、响应时间、并发数）
- 有优化前后对比
- 体现量化思维

### 3. 引导话题
- 主动提到你熟悉的技术点
- 把面试官引导到你的优势领域
- 展示技术深度

### 4. 诚实应对
- 不会的诚实说不会，不要瞎编
- 可以说"这个我了解过但没实际用过"
- 表示愿意学习

### 5. 项目对比
- 可以对比其他项目
- 说明这个项目的特殊之处
- 体现项目价值

---

## 🎯 高频追问

1. "你说你用了分布式锁，如果Redis挂了怎么办？"
   → 降级方案、高可用方案

2. "为什么不用数据库锁？"
   → 性能对比、实际测试数据

3. "如果流量继续增大10倍怎么办？"
   → 扩容方案、分库分表、CDN

4. "你这个项目上线了吗？有多少用户？"
   → 诚实说明这是个人项目，但技术方案是参考真实生产环境

5. "你在这个项目中承担什么角色？"
   → 全栈开发，独立完成设计和开发

---

祝您面试顺利！🎉


